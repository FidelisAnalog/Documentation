<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Analog Signal Composition</title>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=IBM+Plex+Sans:wght@300;400;500;600&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  html, body, #root {
    width: 100%; height: 100%;
    background: #0b0e14;
    font-family: 'IBM Plex Mono', 'SF Mono', monospace;
    color: rgba(255,255,255,0.7);
    overflow: hidden;
  }
  input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    height: 4px;
    border-radius: 2px;
    background: rgba(255,255,255,0.1);
    outline: none;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: currentColor;
    cursor: pointer;
    border: 2px solid rgba(0,0,0,0.3);
  }
  input[type="range"]::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: currentColor;
    cursor: pointer;
    border: 2px solid rgba(0,0,0,0.3);
  }
  .scroll-area::-webkit-scrollbar { width: 6px; }
  .scroll-area::-webkit-scrollbar-track { background: transparent; }
  .scroll-area::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.12); border-radius: 3px; }
  .scroll-area::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.2); }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.3.1/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.3.1/umd/react-dom.production.min.js"></script>
</head>
<body>
<div id="root"></div>
<script>
"use strict";
var h = React.createElement;
var useState = React.useState;
var useRef = React.useRef;
var useEffect = React.useEffect;
var useCallback = React.useCallback;

var COLORS = {
  sig1: "#00e5ff",
  sig2: "#ff2d7b",
  sig3: "#ffc400",
  composite: "#ffffff",
  grid: "rgba(255,255,255,0.06)",
  gridMajor: "rgba(255,255,255,0.12)",
  bg: "#0b0e14",
  panelBg: "#0f1319",
  border: "rgba(255,255,255,0.08)",
  text: "rgba(255,255,255,0.7)",
  textDim: "rgba(255,255,255,0.35)",
};

var DEFAULTS = [
  { freq: 220, amp: 0.8, label: "Signal A", color: COLORS.sig1 },
  { freq: 660, amp: 0.5, label: "Signal B", color: COLORS.sig2 },
  { freq: 1540, amp: 0.3, label: "Signal C", color: COLORS.sig3 },
];

function drawGrid(ctx, w, ht) {
  var divisions = 10, sub = 5, i, x, y;
  ctx.strokeStyle = COLORS.grid; ctx.lineWidth = 1;
  for (i = 0; i <= divisions * sub; i++) {
    x = (w / (divisions * sub)) * i;
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, ht); ctx.stroke();
  }
  for (i = 0; i <= 8 * sub; i++) {
    y = (ht / (8 * sub)) * i;
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
  }
  ctx.strokeStyle = COLORS.gridMajor; ctx.lineWidth = 1;
  for (i = 0; i <= divisions; i++) {
    x = (w / divisions) * i;
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, ht); ctx.stroke();
  }
  for (i = 0; i <= 8; i++) {
    y = (ht / 8) * i;
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
  }
  ctx.strokeStyle = "rgba(255,255,255,0.18)"; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(0, ht / 2); ctx.lineTo(w, ht / 2); ctx.stroke();
}

function drawWaveform(ctx, w, ht, points, color, lw, glow) {
  if (glow) { ctx.shadowColor = color; ctx.shadowBlur = 12; }
  ctx.strokeStyle = color; ctx.lineWidth = lw;
  ctx.lineJoin = "round"; ctx.lineCap = "round";
  ctx.beginPath();
  for (var i = 0; i < points.length; i++) {
    var x = (i / (points.length - 1)) * w;
    var y = ht / 2 - points[i] * (ht / 2) * 0.85;
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  }
  ctx.stroke(); ctx.shadowBlur = 0;
}

function generateSine(freq, amp, n, tw) {
  var pts = [];
  for (var i = 0; i < n; i++) {
    var t = (i / (n - 1)) * tw;
    pts.push(amp * Math.sin(2 * Math.PI * freq * t));
  }
  return pts;
}

function WaveformCanvas(props) {
  var signals = props.signals, showIndividual = props.showIndividual,
      compositeOnly = props.compositeOnly, height = props.height || 180;
  var canvasRef = useRef(null), containerRef = useRef(null);

  var draw = useCallback(function () {
    var canvas = canvasRef.current, container = containerRef.current;
    if (!canvas || !container) return;
    var rect = container.getBoundingClientRect();
    var dpr = window.devicePixelRatio || 1, w = rect.width, ht = height;
    canvas.width = w * dpr; canvas.height = ht * dpr;
    canvas.style.width = w + "px"; canvas.style.height = ht + "px";
    var ctx = canvas.getContext("2d");
    ctx.scale(dpr, dpr); ctx.clearRect(0, 0, w, ht);
    drawGrid(ctx, w, ht);
    var ns = Math.max(800, Math.round(w * 2)), tw = 0.01;

    if (compositeOnly) {
      if (showIndividual) {
        signals.forEach(function (sig) {
          if (!sig.visible) return;
          drawWaveform(ctx, w, ht, generateSine(sig.freq, sig.amp, ns, tw), sig.color + "40", 1.5, false);
        });
      }
      var comp = new Array(ns).fill(0);
      signals.forEach(function (sig) {
        if (!sig.visible) return;
        var pts = generateSine(sig.freq, sig.amp, ns, tw);
        for (var i = 0; i < ns; i++) comp[i] += pts[i];
      });
      var mv = Math.max.apply(null, comp.map(Math.abs).concat([0.001]));
      var sc = mv > 1 ? 1 / mv : 1;
      drawWaveform(ctx, w, ht, comp.map(function (v) { return v * sc; }), COLORS.composite, 2.5, true);
    } else {
      var sig = signals[0];
      drawWaveform(ctx, w, ht, generateSine(sig.freq, sig.amp, ns, tw), sig.color, 2.5, true);
    }
  }, [signals, showIndividual, compositeOnly, height]);

  useEffect(function () {
    draw();
    window.addEventListener("resize", draw);
    return function () { window.removeEventListener("resize", draw); };
  }, [draw]);

  return h("div", { ref: containerRef, style: { width: "100%", position: "relative" } },
    h("canvas", { ref: canvasRef, style: { display: "block", borderRadius: 6 } })
  );
}

function Slider(props) {
  var display = (typeof props.value === "number" && props.value >= 1000)
    ? (props.value / 1000).toFixed(1) + " k"
    : props.value.toFixed(props.step < 1 ? 1 : 0);
  return h("div", { style: { display: "flex", alignItems: "center", gap: 8, marginBottom: 3 } },
    h("span", { style: { fontFamily: "'IBM Plex Mono', monospace", fontSize: 10, color: COLORS.textDim, width: 28, textAlign: "right", flexShrink: 0 } }, props.label),
    h("input", { type: "range", min: props.min, max: props.max, step: props.step, value: props.value, onChange: function (ev) { props.onChange(parseFloat(ev.target.value)); }, style: { flex: 1, color: props.color, height: 4, cursor: "pointer" } }),
    h("span", { style: { fontFamily: "'IBM Plex Mono', monospace", fontSize: 11, color: COLORS.text, width: 64, textAlign: "right", flexShrink: 0 } }, display + " " + props.unit)
  );
}

function SignalPanel(props) {
  var sig = props.signal, idx = props.index, onChange = props.onChange;
  var freqLabel = sig.freq >= 1000
    ? (sig.freq / 1000).toFixed(sig.freq % 1000 === 0 ? 0 : 1) + " kHz"
    : sig.freq + " Hz";
  return h("div", { style: { background: COLORS.panelBg, border: "1px solid " + COLORS.border, borderRadius: 8, padding: "10px 12px", display: "flex", flexDirection: "column", gap: 6 } },
    h("div", { style: { display: "flex", alignItems: "center", gap: 8 } },
      h("div", { style: { width: 8, height: 8, borderRadius: "50%", background: sig.color, boxShadow: "0 0 6px " + sig.color + "60", flexShrink: 0 } }),
      h("span", { style: { fontFamily: "'IBM Plex Mono', monospace", fontSize: 12, fontWeight: 600, color: sig.color, letterSpacing: "0.04em" } }, sig.label),
      h("span", { style: { marginLeft: "auto", fontFamily: "'IBM Plex Mono', monospace", fontSize: 10, color: COLORS.textDim } }, freqLabel)
    ),
    h(WaveformCanvas, { signals: [sig], height: 56 }),
    h("div", null,
      h(Slider, { label: "freq", value: sig.freq, min: 50, max: 5000, step: 10, unit: "Hz", color: sig.color, onChange: function (v) { onChange(idx, "freq", v); } }),
      h(Slider, { label: "amp", value: sig.amp, min: 0, max: 1, step: 0.05, unit: "", color: sig.color, onChange: function (v) { onChange(idx, "amp", v); } })
    )
  );
}

function App() {
  var st = useState(DEFAULTS.map(function (d) { return Object.assign({}, d, { visible: true }); }));
  var signals = st[0], setSignals = st[1];
  var tr = useState(true);
  var showTraces = tr[0], setShowTraces = tr[1];

  var handleChange = function (index, key, value) {
    setSignals(function (prev) {
      var next = prev.slice();
      next[index] = Object.assign({}, next[index]);
      next[index][key] = value;
      return next;
    });
  };

  var toggleVis = function (index) {
    setSignals(function (prev) {
      var next = prev.slice();
      next[index] = Object.assign({}, next[index], { visible: !next[index].visible });
      return next;
    });
  };

  // Full-height flex layout: fixed composite top, scrollable sources bottom
  return h("div", { style: { background: COLORS.bg, height: "100vh", display: "flex", flexDirection: "column", fontFamily: "'IBM Plex Mono', 'SF Mono', monospace", color: COLORS.text } },

    // === FIXED TOP: Composite ===
    h("div", { style: { flexShrink: 0, padding: "16px 24px 12px", maxWidth: 960, width: "100%", margin: "0 auto" } },

      // Header row - compact inline
      h("div", { style: { display: "flex", alignItems: "baseline", justifyContent: "space-between", marginBottom: 10, flexWrap: "wrap", gap: 8 } },
        h("div", { style: { display: "flex", alignItems: "baseline", gap: 12 } },
          h("h1", { style: { fontFamily: "'IBM Plex Sans', sans-serif", fontSize: 18, fontWeight: 400, color: "#fff", margin: 0, letterSpacing: "0.01em" } }, "Analog Signal Composition"),
          h("span", { style: { fontSize: 11, color: COLORS.textDim, fontFamily: "'IBM Plex Sans', sans-serif" } }, "A + B + C")
        ),
        h("div", { style: { display: "flex", alignItems: "center", gap: 10, flexWrap: "wrap" } },
          h("button", {
            onClick: function () { setShowTraces(!showTraces); },
            style: { background: showTraces ? "rgba(255,255,255,0.08)" : "transparent", border: "1px solid " + (showTraces ? "rgba(255,255,255,0.2)" : COLORS.border), borderRadius: 5, padding: "4px 10px", cursor: "pointer", fontFamily: "'IBM Plex Mono', monospace", fontSize: 10, color: showTraces ? COLORS.text : COLORS.textDim, transition: "all 0.2s" }
          }, (showTraces ? "\u2611" : "\u2610") + " Show sources"),
          signals.map(function (sig, i) {
            return h("button", {
              key: i, onClick: function () { toggleVis(i); },
              style: { background: sig.visible ? sig.color + "18" : "transparent", border: "1px solid " + (sig.visible ? sig.color + "50" : COLORS.border), borderRadius: 5, padding: "4px 8px", cursor: "pointer", display: "flex", alignItems: "center", gap: 5, transition: "all 0.2s" }
            },
              h("div", { style: { width: 7, height: 7, borderRadius: "50%", background: sig.visible ? sig.color : "transparent", border: "1.5px solid " + sig.color, transition: "all 0.2s" } }),
              h("span", { style: { fontFamily: "'IBM Plex Mono', monospace", fontSize: 10, color: sig.visible ? sig.color : COLORS.textDim } }, sig.label.split(" ")[1])
            );
          })
        )
      ),

      // Composite waveform
      h("div", { style: { background: COLORS.panelBg, border: "1px solid " + COLORS.border, borderRadius: 8, padding: "10px 12px" } },
        h(WaveformCanvas, { signals: signals, showIndividual: showTraces, compositeOnly: true, height: 200 }),
        h("div", { style: { marginTop: 6, textAlign: "center", fontSize: 10, color: COLORS.textDim, fontFamily: "'IBM Plex Mono', monospace" } },
          "time window: 10 ms  \u00B7  horizontal: time \u2192   vertical: amplitude (voltage)"
        )
      )
    ),

    // === Separator ===
    h("div", { style: { flexShrink: 0, padding: "0 24px", maxWidth: 960, width: "100%", margin: "0 auto" } },
      h("div", { style: { display: "flex", alignItems: "center", justifyContent: "center", gap: 12, padding: "8px 0" } },
        h("div", { style: { height: 1, flex: 1, maxWidth: 100, background: "linear-gradient(to right, transparent, rgba(255,255,255,0.15))" } }),
        h("span", { style: { fontSize: 10, color: COLORS.textDim, textTransform: "uppercase", letterSpacing: "0.15em", fontFamily: "'IBM Plex Sans', sans-serif" } }, "Source Signals"),
        h("div", { style: { height: 1, flex: 1, maxWidth: 100, background: "linear-gradient(to left, transparent, rgba(255,255,255,0.15))" } })
      )
    ),

    // === SCROLLABLE BOTTOM: Source signals + explanation ===
    h("div", {
      className: "scroll-area",
      style: { flex: 1, overflowY: "auto", overflowX: "hidden", padding: "0 24px 20px" }
    },
      h("div", { style: { maxWidth: 960, margin: "0 auto" } },

        // Signal panels grid
        h("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(270px, 1fr))", gap: 12, marginBottom: 16 } },
          signals.map(function (sig, i) {
            return h(SignalPanel, { key: i, signal: sig, index: i, onChange: handleChange });
          })
        ),

        // Explanation text
        h("div", { style: { padding: "10px 14px", background: "rgba(255,255,255,0.02)", borderRadius: 8, border: "1px solid " + COLORS.border } },
          h("p", { style: { margin: 0, fontSize: 12, lineHeight: 1.6, color: COLORS.textDim, fontFamily: "'IBM Plex Sans', sans-serif" } },
            "An analog audio signal is a continuously varying electrical voltage. When multiple sound sources exist simultaneously, their voltages add together at every instant in time \u2014 this is ",
            h("span", { style: { color: "#fff" } }, "superposition"),
            ". The composite waveform above is the point-by-point sum of all three source signals. A loudspeaker\u2019s diaphragm follows this single composite voltage to reproduce the original sounds."
          )
        )
      )
    )
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(h(App));
</script>
</body>
</html>
